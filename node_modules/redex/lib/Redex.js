
// Copyright (c) 2015, Evan Summers (twitter.com/evanxsummers)
// ISC license, see http://github.com/evanx/redex/LICENSE

import assert from 'assert';
import lodash from 'lodash';
import fs from 'fs';
import util from 'util';

import RedexProcessors from './RedexProcessors';

const logger = RedexGlobal.logger(module.filename);

export default class Redex {

   constructor(config) {
      assert(config.monitorInterval, 'monitorInterval');
      this.config = config;
      if (!config.baseDir) {
         logger.debug('no baseDir:', Object.keys(config).join(', '));
      }
      this.processorMap = new Map();
      this.processorKeys = []; // in startup order
      this.startedProcessorKeys = [];
      this.resolve = {
         routes: new Set(),
         processors: new Set(),
      };
      this.cancelled = config.env.cancelled;
      this.ended = false;
      this.pidFile = process.env.pidFile;
      this.startTimeout = config.startTimeout || 4000;
      logger.debug('constructor', this.constructor.name, this.config);
   }

   get lifecycle() {
      if (this.ended) {
         return 'ended';
      } else if (this.cancelled) {
         return 'cancelled';
      } else {
         return 'running';
      }
   }

   resolveRoute(route, sourceProcessor, message) {
      assert(lodash.isArray(route) && route.length && lodash.isString(route[0]), 'route');
      this.resolve.routes.add({route, sourceProcessor, message});
   }

   resolveProcessor(processorName, sourceProcessor, message) {
      assert(processorName, 'processorName');
      this.resolve.processors.add({processorName, sourceProcessor, message});
   }

   initProcessors() {
      for (let processorName of [...this.processorKeys]) {
         let processor = this.processorMap.get(processorName);
         assert(processor, processorName);
         if (lodash.isFunction(processor.init)) {
            logger.info('init', processorName);
            try {
               processor.init();
            } catch (err) {
               logger.error('init', processorName, err);
               throw err;
            }
         } else {
            logger.warn('init', processorName);
         }
      }
   }

   async startProcessors() {
      for (let processorName of [...this.processorKeys]) {
         let processor = this.processorMap.get(processorName);
         if (lodash.isFunction(processor.start)) {
            logger.info('start', processorName);
            try {
               await Promises.timeout(processorName, this.config.startTimeout, processor.start());
               this.startedProcessorKeys.push(processorName);
            } catch (err) {
               logger.error('start', processorName, err);
               throw err;
            }
         } else {
            logger.warn('start', processorName);
         }
      }
   }

   endProcessors() {
      for (let processorName of [...this.startedProcessorKeys]) {
         let processor = this.processorMap.get(processorName);
         if (lodash.isFunction(processor.end)) {
            logger.info('end', proc